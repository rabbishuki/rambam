<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Track your daily Rambam (3 chapters) study with swipeable cards">
  <meta name="theme-color" content="#2563eb">
  <title>×¨××‘"× ×™×•××™</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Hebrew:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="changelog.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Noto Sans Hebrew', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      color: #1f2937;
      -webkit-font-smoothing: antialiased;
      touch-action: pan-y;
    }

    .container {
      max-width: 640px;
      margin: 0 auto;
      min-height: 100vh;
      background: #ffffff;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    }

    /* Header */
    header {
      background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
      color: white;
      padding: 1.25rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      position: sticky;
      top: 0;
      z-index: 101;
      transition: background 0.3s;
    }

    header.viewing-other-date {
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
    }

    .header-content {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .logo {
      width: 36px;
      height: 36px;
      border-radius: 8px;
    }

    h1 {
      font-size: 1.5rem;
      font-weight: 700;
    }

    .header-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .header-date-picker {
      display: none;
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .header-btn {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      font-size: 1.5rem;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    .header-btn:active {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Stats Bar */
    .stats {
      background: #f9fafb;
      padding: 1rem;
      display: flex;
      justify-content: space-around;
      border-bottom: 2px solid #e5e7eb;
      gap: 0.5rem;
      position: sticky;
      top: 72px;
      z-index: 100;
    }

    .stat {
      text-align: center;
      flex: 1;
    }

    .stat-value {
      font-size: 1.75rem;
      font-weight: 700;
      color: #2563eb;
      display: block;
    }

    .stat-label {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 0.25rem;
    }

    /* Main Content */
    main {
      padding: 1rem;
      padding-bottom: 2rem;
    }

    .day-group {
      margin-bottom: 1rem;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      overflow: hidden;
      background: white;
    }

    .day-group.completed {
      opacity: 0.6;
      border-color: #10b981;
    }

    summary {
      padding: 1rem;
      cursor: pointer;
      list-style: none;
      background: linear-gradient(to bottom, #ffffff, #f9fafb);
      font-size: 1.125rem;
      font-weight: 600;
      color: #1f2937;
      border-bottom: 1px solid #e5e7eb;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
    }

    summary::-webkit-details-marker {
      display: none;
    }

    .day-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      flex: 1;
    }

    .day-arrow {
      color: #6b7280;
      transition: transform 0.2s;
      font-size: 1rem;
      line-height: 1;
    }

    details[open] .day-arrow {
      transform: rotate(-90deg);
    }

    .day-info {
      flex: 1;
    }

    .day-actions {
      display: flex;
      gap: 0.25rem;
      align-items: center;
    }

    .day-action-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.5rem;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
      font-size: 1.25rem;
      line-height: 1;
      color: #9ca3af;
      width: 36px;
      height: 36px;
    }

    .day-action-btn.reset {
      font-size: 1.5rem;
    }

    .day-action-btn:hover {
      background: rgba(0, 0, 0, 0.05);
      color: #6b7280;
    }

    .day-action-btn:active {
      background: rgba(0, 0, 0, 0.1);
      color: #4b5563;
    }

    summary:active {
      background: #f3f4f6;
    }

    .day-meta {
      font-size: 0.875rem;
      color: #6b7280;
      margin-top: 0.25rem;
    }

    .cards-container {
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .loading {
      text-align: center;
      padding: 2rem;
      color: #6b7280;
      font-style: italic;
    }

    /* Halakha Cards */
    .halakha-card {
      background: white;
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      padding: 1rem;
      font-size: 1.125rem;
      line-height: 1.8;
      color: #1f2937;
      position: relative;
      transition: transform 0.3s, opacity 0.3s, box-shadow 0.2s;
      touch-action: pan-y;
      cursor: grab;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .halakha-card:active {
      cursor: grabbing;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .halakha-card.swiping {
      transition: none;
    }

    .halakha-card.completed {
      opacity: 0.4;
      background: #f3f4f6;
      border-color: #d1d5db;
    }

    .halakha-card.completed .halakha-text {
      text-decoration: line-through;
      color: #6b7280;
    }

    .halakha-text {
      text-align: justify;
    }

    .halakha-text b {
      font-weight: 700;
      color: #1f2937;
    }

    .halakha-text small {
      font-size: 0.9em;
      color: #6b7280;
    }

    /* Chapter Divider */
    .chapter-divider {
      text-align: center;
      margin: 1.5rem 0 1rem;
      position: relative;
    }

    .chapter-divider::before,
    .chapter-divider::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 40%;
      height: 1px;
      background: linear-gradient(to right, transparent, #d1d5db, transparent);
    }

    .chapter-divider::before {
      left: 0;
    }

    .chapter-divider::after {
      right: 0;
    }

    .chapter-divider span {
      background: white;
      padding: 0.5rem 1rem;
      font-size: 1rem;
      font-weight: 600;
      color: #2563eb;
      border: 1px solid #e5e7eb;
      border-radius: 20px;
      display: inline-block;
      position: relative;
      z-index: 1;
    }

    /* Settings Panel */
    .settings-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      max-width: 400px;
      height: 100vh;
      background: white;
      box-shadow: 4px 0 16px rgba(0, 0, 0, 0.2);
      transform: translateX(-100%);
      transition: transform 0.3s;
      z-index: 1000;
      display: flex;
      flex-direction: column;
    }

    .settings-panel.open {
      transform: translateX(0);
    }

    .settings-header {
      background: #2563eb;
      color: white;
      padding: 1.25rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .settings-header h2 {
      font-size: 1.25rem;
      font-weight: 700;
    }

    .close-btn {
      background: none;
      border: none;
      color: white;
      font-size: 1.75rem;
      cursor: pointer;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }

    .close-btn:active {
      background: rgba(255, 255, 255, 0.2);
    }

    .settings-content {
      padding: 0;
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .settings-scrollable {
      flex: 1;
      overflow-y: auto;
    }

    .settings-section {
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      border-bottom: 1px solid #e5e7eb;
    }

    .settings-section:last-of-type {
      border-bottom: none;
    }

    .settings-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: #374151;
    }

    .toggle-container {
      display: flex;
      gap: 0.5rem;
      background: #f3f4f6;
      padding: 0.25rem;
      border-radius: 8px;
    }

    .toggle-btn {
      flex: 1;
      padding: 0.625rem 1rem;
      border: none;
      background: transparent;
      color: #6b7280;
      font-size: 0.875rem;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .toggle-btn:hover {
      color: #374151;
    }

    .toggle-btn.active {
      background: white;
      color: #2563eb;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .date-row {
      display: flex;
      gap: 0.5rem;
      align-items: stretch;
    }

    .date-row > * {
      flex: 1;
      min-width: 0;
    }

    .date-input {
      padding: 0.75rem;
      border: 2px solid #2563eb;
      border-radius: 8px;
      font-size: 1rem;
      font-family: inherit;
      transition: all 0.2s;
      background: white;
    }

    .date-input-inactive {
      background: #f3f4f6;
      color: #9ca3af;
      border-color: #d1d5db;
    }

    .btn-compact {
      white-space: nowrap;
      padding: 0.6rem 1rem;
    }

    .btn-secondary {
      background: #f9fafb;
      border-color: #e5e7eb;
      color: #9ca3af;
    }

    .btn-secondary:hover {
      background: #f3f4f6;
      border-color: #d1d5db;
      color: #6b7280;
    }

    .btn-secondary:active {
      background: #e5e7eb;
    }

    .btn {
      border: 1px solid #d1d5db;
      padding: 0.75rem 1rem;
      font-size: 0.875rem;
      font-weight: 500;
      border-radius: 6px;
      cursor: pointer;
      width: 100%;
      transition: all 0.2s;
      background: white;
      color: #374151;
    }

    .btn:hover {
      background: #f9fafb;
      border-color: #9ca3af;
    }

    .btn:active {
      background: #f3f4f6;
    }

    .btn-primary {
      background: #eff6ff;
      border-color: #2563eb;
      color: #2563eb;
    }

    .btn-primary:hover {
      background: #dbeafe;
    }

    .btn-primary:active {
      background: #bfdbfe;
    }

    .btn-danger {
      background: #fef2f2;
      border-color: #dc2626;
      color: #dc2626;
    }

    .btn-danger:hover {
      background: #fee2e2;
    }

    .btn-danger:active {
      background: #fecaca;
    }

    .settings-warning {
      color: #6b7280;
      font-size: 0.875rem;
      text-align: center;
    }

    /* Overlay */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      z-index: 999;
    }

    .overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 3rem 1.5rem;
      color: #6b7280;
    }

    .empty-state-icon {
      font-size: 4rem;
      margin-bottom: 1rem;
    }

    .empty-state-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #1f2937;
      margin-bottom: 0.5rem;
    }

    .empty-state-text {
      font-size: 1rem;
      line-height: 1.6;
    }

    /* Install Prompt */
    .install-prompt {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      right: 1rem;
      max-width: 500px;
      margin: 0 auto;
      background: white;
      border: 2px solid #2563eb;
      border-radius: 12px;
      padding: 1rem;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
      animation: slideUp 0.3s ease-out;
    }

    .install-prompt.show {
      display: block;
    }

    @keyframes slideUp {
      from {
        transform: translateY(100px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .install-prompt-content {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .install-prompt-text {
      font-size: 0.95rem;
      color: #1f2937;
      font-weight: 500;
    }

    .install-prompt-buttons {
      display: flex;
      gap: 0.5rem;
    }

    .install-prompt-btn {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    .install-prompt-btn.primary {
      background: #2563eb;
      color: white;
    }

    .install-prompt-btn.primary:active {
      background: #1d4ed8;
    }

    .install-prompt-btn.secondary {
      background: #f3f4f6;
      color: #6b7280;
    }

    .install-prompt-btn.secondary:active {
      background: #e5e7eb;
    }

    .dedication {
      background: #fef3c7;
      padding: 1rem;
      text-align: center;
      font-size: 0.875rem;
      color: #92400e;
      font-weight: 500;
    }

    .dedication b {
      font-weight: 700;
    }

    .footer {
      background: #f9fafb;
      padding: 0.5rem 1.5rem;
      text-align: center;
      font-size: 0.75rem;
      color: #6b7280;
    }

    .footer-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.25rem;
      flex-wrap: wrap;
      line-height: 1.6;
    }

    .footer-badge {
      margin-right: 0.5rem;
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      padding: 0.2rem 0.4rem;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      background: white;
    }

    .footer-avatar {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      object-fit: cover;
    }

    .footer-link {
      color: inherit;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    .footer-link:hover {
      opacity: 0.8;
    }

    .claude-icon {
      width: 18px;
      height: 18px;
      vertical-align: middle;
    }

    .whatsapp-icon {
      width: 16px;
      height: 16px;
      vertical-align: middle;
    }

    .settings-dedication {
      background: #fef3c7;
      padding: 1rem;
      text-align: center;
      font-size: 0.875rem;
      color: #92400e;
      font-weight: 500;
    }

    .yechi {
      background: #667eea;
      color: white;
      padding: 0.5rem;
    }

    .changelog-version {
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 0.5rem;
    }

    .changelog-version:last-child {
      margin-bottom: 0;
    }

    .changelog-version summary {
      padding: 0.75rem;
      cursor: pointer;
      background: #f9fafb;
      font-weight: 600;
      font-size: 0.875rem;
      color: #374151;
      user-select: none;
      list-style: none;
    }

    .changelog-version summary::-webkit-details-marker {
      display: none;
    }

    .changelog-version summary:hover {
      background: #f3f4f6;
    }

    .changelog-arrow {
      color: #6b7280;
      transition: transform 0.2s;
      display: inline-block;
      margin-left: 0.5rem;
    }

    .changelog-version[open] .changelog-arrow {
      transform: rotate(-90deg);
    }

    .changelog-items {
      padding: 0.75rem;
      background: white;
    }

    .changelog-item {
      padding: 0.5rem 0;
      font-size: 0.875rem;
      color: #6b7280;
      line-height: 1.5;
      border-bottom: 1px solid #f3f4f6;
    }

    .changelog-item:last-child {
      border-bottom: none;
    }

    .changelog-item::before {
      content: 'â€¢ ';
      color: #2563eb;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <header id="mainHeader">
      <div class="header-content">
        <img src="logo.png" alt="Logo" class="logo">
        <h1>×¨××‘"× ×™×•××™</h1>
      </div>
      <div class="header-actions">
        <input type="date" class="header-date-picker" id="headerDatePicker" aria-label="×‘×—×¨ ×ª××¨×™×š">
        <button class="header-btn" id="installHeaderBtn" aria-label="×”×ª×§×Ÿ ××¤×œ×™×§×¦×™×”" style="display: none;">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
          </svg>
        </button>
        <button class="header-btn" id="calendarBtn" aria-label="×‘×—×¨ ×ª××¨×™×š">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="16" y1="2" x2="16" y2="6"></line>
            <line x1="8" y1="2" x2="8" y2="6"></line>
            <line x1="3" y1="10" x2="21" y2="10"></line>
          </svg>
        </button>
        <button class="header-btn" id="settingsBtn" aria-label="×”×’×“×¨×•×ª">âš™</button>
      </div>
    </header>

    <div class="stats">
      <div class="stat">
        <span class="stat-value" id="completedDaysValue">0/0</span>
        <div class="stat-label">×™××™× ×©×œ××“×ª×™</div>
      </div>
      <div class="stat">
        <span class="stat-value" id="todayValue">0%</span>
        <div class="stat-label">×”×™×•×</div>
      </div>
      <div class="stat">
        <span class="stat-value" id="backlogValue">0</span>
        <div class="stat-label">×”×œ×›×•×ª ×œ×”×©×œ×™×</div>
      </div>
    </div>

    <main id="mainContent"></main>
  </div>

  <div class="overlay" id="overlay"></div>

  <div class="install-prompt" id="installPrompt">
    <div class="install-prompt-content">
      <div class="install-prompt-text">
        ğŸ’¡ ×”×ª×§×Ÿ ××ª ×”××¤×œ×™×§×¦×™×” ×œ××¡×š ×”×‘×™×ª ×œ×’×™×©×” ××”×™×¨×” ×•×©×™××•×© ×œ×œ× ××™× ×˜×¨× ×˜!
      </div>
      <div class="install-prompt-buttons">
        <button class="install-prompt-btn primary" id="installBtn">×”×ª×§×Ÿ</button>
        <button class="install-prompt-btn secondary" id="dismissInstallBtn">××•×œ×™ ×××•×—×¨ ×™×•×ª×¨</button>
      </div>
    </div>
  </div>

  <div class="settings-panel" id="settingsPanel">
    <div class="settings-header">
      <h2>×”×’×“×¨×•×ª</h2>
      <button class="close-btn" id="closeBtn" aria-label="×¡×’×•×¨">Ã—</button>
    </div>
    <div class="settings-content">
      <div class="settings-scrollable">
        <div class="settings-section">
          <label class="settings-label">×ª××¨×™×š ×”×ª×—×œ×ª ×œ×™××•×“</label>
          <div class="date-row">
            <button class="btn btn-primary btn-compact" id="setCycleBtn">××—×–×•×¨ 46</button>
            <input type="date" class="date-input" id="startDateInput">
          </div>
        </div>

        <div class="settings-section">
          <label class="settings-label">××¡×¤×¨ ×¤×¨×§×™× ×œ×™×•×</label>
          <div class="toggle-container">
            <button class="toggle-btn active" data-value="3">3 ×¤×¨×§×™×</button>
            <button class="toggle-btn" data-value="1">×¤×¨×§ ××—×“</button>
          </div>
        </div>

        <div class="settings-section">
          <label class="settings-label">×¡×™××•×Ÿ ×”×œ×›×•×ª ×§×•×“××•×ª ×›× ×§×¨××•</label>
          <div class="toggle-container">
            <button class="toggle-btn auto-mark active" data-value="true">×›×Ÿ</button>
            <button class="toggle-btn auto-mark" data-value="false">×œ×</button>
          </div>
        </div>

        <div class="settings-section">
          <label class="settings-label">××™×§×•× ×•×©×§×™×¢×”</label>
          <div style="display: flex; flex-direction: column; gap: 0.5rem; padding: 0.75rem; background: #f9fafb; border-radius: 8px; font-size: 0.875rem; color: #374151;">
            <div id="locationText">××™×§×•×: ×ª×œ ××‘×™×‘ (×‘×¨×™×¨×ª ××—×“×œ)</div>
            <div id="sunsetText">×©×§×™×¢×”: 18:00</div>
          </div>
          <button class="btn btn-primary" id="updateLocationBtn">×¢×“×›×Ÿ ××™×§×•× ×•×©×§×™×¢×”</button>
        </div>

        <div class="settings-section">
          <p class="settings-warning">âš ï¸ ×¤×¢×•×œ×” ×–×• ×ª××—×§ ××ª ×›×œ ×”×”×ª×§×“××•×ª ×©×œ×š</p>
          <button class="btn btn-danger" id="resetBtn">××™×¤×•×¡ ××œ×</button>
        </div>

        <div class="settings-section">
          <label class="settings-label">×¨×©×™××ª ×©×™× ×•×™×™×</label>
          <div id="changelogContainer"></div>
        </div>
      </div>

      <div class="settings-dedication">
        ×œ×¢×™×œ×•×™ × ×©××ª <b>×™×©×¨××œ ×©××•×œ</b> ×‘×Ÿ <b>××©×” ××”×¨×•×Ÿ</b> ×•<b>××œ×›×”</b> ×‘×ª <b>× ×ª×Ÿ</b>
      </div>

      <footer class="footer">
        <div class="footer-content">
          <div class="footer-badge">
            <img src="claude.jpeg" alt="Claude" class="claude-icon">
            <span style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;">Claude Code</span>
          </div>
          <span>×‘× ×”,</span>
          <a href="https://wa.me/972586030770?text=××”×‘×ª×™%20××ª%20×”××¤×œ×™×§×¦×™×”%20×©×œ%20×”×¨××‘×" class="footer-link" target="_blank" rel="noopener" aria-label="×©×œ×— ×”×•×“×¢×” ×‘×•×•××˜×¡××¤">
            <div class="footer-badge">
              <img src="rabbi.jpeg" alt="×”×¨×‘ ×©×•×§×™" class="footer-avatar">
              <span>×”×¨×‘ ×©×•×§×™</span>
              <svg class="whatsapp-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.87 9.87 0 01-5.031-1.378l-.361-.214-3.741.982.998-3.648-.235-.374a9.86 9.86 0 01-1.51-5.26c.001-5.45 4.436-9.884 9.888-9.884 2.64 0 5.122 1.03 6.988 2.898a9.825 9.825 0 012.893 6.994c-.003 5.45-4.437 9.884-9.885 9.884m8.413-18.297A11.815 11.815 0 0012.05 0C5.495 0 .16 5.335.157 11.892c0 2.096.547 4.142 1.588 5.945L.057 24l6.305-1.654a11.882 11.882 0 005.683 1.448h.005c6.554 0 11.89-5.335 11.893-11.893a11.821 11.821 0 00-3.48-8.413Z" fill="#25D366"/>
              </svg>
            </div>
          </a>
          <span>×”×’×” ×•×”×›×•×•×™×Ÿ.</span>
        </div>
      </footer>
      
      <div class="settings-dedication yechi">
        ×™×—×™ ××“×•× × ×• ××•×¨× ×• ×•×¨×‘×™× ×• ××œ×š ×”××©×™×— ×œ×¢×•×œ× ×•×¢×“
      </div>
    </div>
  </div>

  <script>
    // ============================================================================
    // Constants & State
    // ============================================================================
    const SEFARIA_API = 'https://www.sefaria.org';
    const HEBCAL_API = 'https://www.hebcal.com';
    const DEFAULT_COORDS = { latitude: 32.0853, longitude: 34.7818 }; // Tel Aviv fallback
    const textCache = new Map(); // In-memory cache for halakha texts
    let cachedSunsetHour = 18;   // fallback
    let cachedSunsetMinute = 0;
    let cachedCoords = DEFAULT_COORDS;
    let isUsingDefaultLocation = true;
    let cachedLocationName = '×ª×œ ××‘×™×‘';

    function getUserCoords() {
      return new Promise((resolve) => {
        if (!navigator.geolocation) {
          console.log('Geolocation not supported, using Tel Aviv');
          isUsingDefaultLocation = true;
          resolve(DEFAULT_COORDS);
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            console.log('Got user location:', pos.coords.latitude, pos.coords.longitude);
            isUsingDefaultLocation = false;
            resolve({ latitude: pos.coords.latitude, longitude: pos.coords.longitude });
          },
          (error) => {
            console.log('Geolocation error:', error.message, '- using Tel Aviv');
            isUsingDefaultLocation = true;
            resolve(DEFAULT_COORDS);
          },
          { timeout: 5000 }
        );
      });
    }

    // ============================================================================
    // LocalStorage Utilities
    // ============================================================================
    const CYCLE_START = '2026-02-03';

    function getStart() {
      const stored = localStorage.getItem('rambam_start');
      // If not set, return the default but don't save it yet
      return stored || CYCLE_START;
    }

    function setStart(dateStr) {
      localStorage.setItem('rambam_start', dateStr);
    }

    function getChapterCount() {
      const stored = localStorage.getItem('rambam_chapters');
      return stored ? parseInt(stored) : 3;
    }

    function setChapterCount(count) {
      localStorage.setItem('rambam_chapters', count.toString());
    }

    function getAutoMark() {
      const stored = localStorage.getItem('rambam_auto_mark');
      return stored === null ? true : stored === 'true';
    }

    function setAutoMark(enabled) {
      localStorage.setItem('rambam_auto_mark', enabled.toString());
    }

    function isFirstVisit() {
      return !localStorage.getItem('rambam_start');
    }

    function getTodayInIsrael() {
      // Get current time in Israel timezone (Asia/Jerusalem)
      const now = new Date();
      const israelTimeStr = now.toLocaleString('en-US', { timeZone: 'Asia/Jerusalem' });
      const israelTime = new Date(israelTimeStr);
      const hour = israelTime.getHours();
      const minute = israelTime.getMinutes();

      // Jewish day starts at sunset (using cached sunset time)
      const isPastSunset = (hour > cachedSunsetHour) ||
                           (hour === cachedSunsetHour && minute >= cachedSunsetMinute);

      let jewishDate = new Date(israelTime);

      if (!isPastSunset) {
        // Before sunset - still in previous Jewish day
        // No adjustment needed, use current calendar date
      } else {
        // After sunset - advance to next Jewish day
        jewishDate.setDate(jewishDate.getDate() + 1);
      }

      const year = jewishDate.getFullYear();
      const month = String(jewishDate.getMonth() + 1).padStart(2, '0');
      const day = String(jewishDate.getDate()).padStart(2, '0');

      return `${year}-${month}-${day}`;
    }

    function getDays() {
      const stored = localStorage.getItem('rambam_days');
      return stored ? JSON.parse(stored) : {};
    }

    function saveDays(days) {
      localStorage.setItem('rambam_days', JSON.stringify(days));
    }

    function getDone() {
      const stored = localStorage.getItem('rambam_done');
      return stored ? JSON.parse(stored) : {};
    }

    function saveDone(done) {
      localStorage.setItem('rambam_done', JSON.stringify(done));
    }

    function markDone(date, index) {
      const done = getDone();
      done[`${date}:${index}`] = new Date().toISOString();
      saveDone(done);
    }

    // ============================================================================
    // Date Utilities
    // ============================================================================
    function dateRange(start, end) {
      const dates = [];
      const current = new Date(start);
      const endDate = new Date(end);
      while (current <= endDate) {
        dates.push(current.toISOString().split('T')[0]);
        current.setDate(current.getDate() + 1);
      }
      return dates;
    }

    function formatHebrewDate(dateStr) {
      const days = getDays();
      const dayData = days[dateStr];

      // Try to use cached Hebrew date first
      if (dayData && dayData.heDate) {
        return dayData.heDate;
      }

      // Fall back to Gregorian format
      const [y, m, d] = dateStr.split('-').map(Number);
      return `${d}/${m}/${y}`;
    }

    function toHebrewLetter(num) {
      const ones = ['×', '×‘', '×’', '×“', '×”', '×•', '×–', '×—', '×˜'];
      const tens = ['', '×™', '×›', '×œ', '×', '× ', '×¡', '×¢', '×¤', '×¦'];
      const hundreds = ['', '×§', '×¨', '×©', '×ª'];

      if (num < 1) return '';

      let result = '';

      // Hundreds
      const hundred = Math.floor(num / 100);
      if (hundred > 0 && hundred < hundreds.length) {
        result += hundreds[hundred];
      }

      // Tens and ones
      const remainder = num % 100;

      // Handle 15 and 16 specially (×˜×•, ×˜×– instead of ×™×”, ×™×• which spell God's name)
      if (remainder === 15) {
        result += '×˜×•';
      } else if (remainder === 16) {
        result += '×˜×–';
      } else if (remainder > 0) {
        if (remainder < 10) {
          result += ones[remainder - 1];
        } else {
          const ten = Math.floor(remainder / 10);
          const one = remainder % 10;
          result += tens[ten];
          if (one > 0) {
            result += ones[one - 1];
          }
        }
      }

      return result || num.toString();
    }

    // ============================================================================
    // Sefaria API
    // ============================================================================
    async function fetchCalendar(dateStr) {
      const [y, m, d] = dateStr.split('-').map(Number);
      const url = `${SEFARIA_API}/api/calendars?day=${d}&month=${m}&year=${y}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Calendar API failed: ${res.status}`);
      const data = await res.json();

      const chapterCount = getChapterCount();
      const searchTitle = chapterCount === 3 ? 'Daily Rambam (3 Chapters)' : 'Daily Rambam';

      const rambam = data.calendar_items.find(item =>
        item.title.en === searchTitle
      );

      if (!rambam) throw new Error('No Rambam entry found');

      return {
        he: rambam.displayValue.he,
        ref: rambam.ref
      };
    }

    async function fetchText(ref) {
      if (textCache.has(ref)) {
        return textCache.get(ref);
      }

      const url = `${SEFARIA_API}/api/v3/texts/${ref}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error(`Text API failed: ${res.status}`);
      const data = await res.json();

      let halakhot = [];
      let chapterBoundaries = []; // Array of indices where new chapters start
      const text = data.versions[0].text;

      if (data.isSpanning) {
        // Track chapter boundaries while flattening
        let currentIndex = 0;
        text.forEach((chapter, chapterNum) => {
          if (chapterNum > 0) {
            chapterBoundaries.push(currentIndex);
          }
          halakhot.push(...chapter);
          currentIndex += chapter.length;
        });
      } else if (Array.isArray(text)) {
        halakhot = text;
      } else {
        halakhot = [text];
      }

      const result = { halakhot, chapterBoundaries };
      textCache.set(ref, result);
      return result;
    }

    async function fetchLocationName(coords) {
      try {
        // Use BigDataCloud's free reverse geocoding API (no API key, no rate limits)
        const url = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${coords.latitude}&longitude=${coords.longitude}&localityLanguage=he`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Geocoding failed: ${res.status}`);
        const data = await res.json();

        console.log('Geocoding response:', data);

        // Try to get city name in Hebrew - locality is most accurate
        const cityName = data.locality || data.city || data.principalSubdivision || '××™×§×•× × ×•×›×—×™';
        console.log('Extracted city name:', cityName);
        return cityName;
      } catch (error) {
        console.error('Failed to fetch location name:', error);
        return '××™×§×•× × ×•×›×—×™';
      }
    }

    async function fetchSunset(dateStr, coords) {
      try {
        cachedCoords = coords;

        // Fetch location name and sunset in parallel
        const [locationName, sunsetRes] = await Promise.all([
          isUsingDefaultLocation ? Promise.resolve('×ª×œ ××‘×™×‘') : fetchLocationName(coords),
          fetch(`${HEBCAL_API}/zmanim?cfg=json&latitude=${coords.latitude}&longitude=${coords.longitude}&date=${dateStr}`)
        ]);

        cachedLocationName = locationName;

        if (!sunsetRes.ok) throw new Error(`Zmanim API failed: ${sunsetRes.status}`);
        const data = await sunsetRes.json();

        if (data.times && data.times.sunset) {
          const sunsetTime = new Date(data.times.sunset);
          cachedSunsetHour = sunsetTime.getHours();
          cachedSunsetMinute = sunsetTime.getMinutes();
        }
        updateLocationDisplay();
      } catch (error) {
        console.error('Failed to fetch sunset time:', error);
        // Keep fallback values (18:00)
        updateLocationDisplay();
      }
    }

    function updateLocationDisplay() {
      const locationText = document.getElementById('locationText');
      const sunsetText = document.getElementById('sunsetText');

      console.log('Updating location display:', {
        cachedLocationName,
        isUsingDefaultLocation,
        cachedSunsetHour,
        cachedSunsetMinute,
        locationText: !!locationText,
        sunsetText: !!sunsetText
      });

      if (locationText) {
        const suffix = isUsingDefaultLocation ? ' (×‘×¨×™×¨×ª ××—×“×œ)' : '';
        locationText.textContent = `××™×§×•×: ${cachedLocationName}${suffix}`;
      }

      if (sunsetText) {
        const hourStr = String(cachedSunsetHour).padStart(2, '0');
        const minStr = String(cachedSunsetMinute).padStart(2, '0');
        sunsetText.textContent = `×©×§×™×¢×”: ${hourStr}:${minStr}`;
      }
    }

    async function fetchHebrewDate(dateStr) {
      try {
        const url = `${HEBCAL_API}/converter?cfg=json&date=${dateStr}`;
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Converter API failed: ${res.status}`);
        const data = await res.json();

        if (data.heDateParts && data.heDateParts.d && data.heDateParts.m) {
          return `${data.heDateParts.d} ${data.heDateParts.m}`;
        }
        return null;
      } catch (error) {
        console.error('Failed to fetch Hebrew date:', error);
        return null;
      }
    }

    // ============================================================================
    // Data Loading
    // ============================================================================
    async function loadMissingDays() {
      const start = getStart();
      const today = getTodayInIsrael();
      const allDates = dateRange(start, today);
      const days = getDays();

      const missing = allDates.filter(date => !days[date]);
      const needHeDate = allDates.filter(date => days[date] && !days[date].heDate);

      // Fetch all missing dates in parallel
      if (missing.length > 0) {
        const results = await Promise.allSettled(
          missing.map(async (date) => {
            const { he, ref } = await fetchCalendar(date);
            const { halakhot } = await fetchText(ref);
            const heDate = await fetchHebrewDate(date);
            return { date, he, ref, count: halakhot.length, heDate };
          })
        );

        results.forEach((result, i) => {
          if (result.status === 'fulfilled') {
            const { date, he, ref, count, heDate } = result.value;
            days[date] = { he, ref, count, heDate };
          } else {
            console.error(`Failed to load ${missing[i]}:`, result.reason);
          }
        });
      }

      // Backfill Hebrew dates for existing days
      if (needHeDate.length > 0) {
        const results = await Promise.allSettled(
          needHeDate.map(async (date) => {
            const heDate = await fetchHebrewDate(date);
            return { date, heDate };
          })
        );

        results.forEach((result, i) => {
          if (result.status === 'fulfilled') {
            const { date, heDate } = result.value;
            if (heDate && days[date]) {
              days[date].heDate = heDate;
            }
          } else {
            console.error(`Failed to fetch Hebrew date for ${needHeDate[i]}:`, result.reason);
          }
        });
      }

      saveDays(days);
    }

    // ============================================================================
    // Stats Computation
    // ============================================================================
    function computeStats() {
      const days = getDays();
      const done = getDone();
      const today = getTodayInIsrael();

      // Completed days: count how many days have been fully completed
      let completedDays = 0;
      let totalDays = 0;

      Object.keys(days).forEach(date => {
        if (date <= today) {
          totalDays++;
          const dayData = days[date];
          const doneCount = Object.keys(done).filter(key =>
            key.startsWith(`${date}:`)
          ).length;

          if (doneCount >= dayData.count) {
            completedDays++;
          }
        }
      });

      // Today percentage
      const todayData = days[today];
      let todayPercent = 0;
      if (todayData) {
        const todayDone = Object.keys(done).filter(key =>
          key.startsWith(`${today}:`)
        ).length;
        todayPercent = Math.round((todayDone / todayData.count) * 100);
      }

      // Backlog: sum of incomplete halakhot before today (not including today)
      let backlog = 0;
      Object.keys(days).forEach(date => {
        if (date < today) {
          const dayData = days[date];
          const doneCount = Object.keys(done).filter(key =>
            key.startsWith(`${date}:`)
          ).length;
          const remaining = dayData.count - doneCount;
          if (remaining > 0) {
            backlog += remaining;
          }
        }
      });

      return { completedDays, totalDays, todayPercent, backlog };
    }

    function renderStats() {
      const { completedDays, totalDays, todayPercent, backlog } = computeStats();
      document.getElementById('completedDaysValue').textContent = `${completedDays}/${totalDays}`;
      document.getElementById('todayValue').textContent = `${todayPercent}%`;
      document.getElementById('backlogValue').textContent = backlog;
    }

    function updateDayHeader(date) {
      const days = getDays();
      const done = getDone();
      const dayData = days[date];
      if (!dayData) return;

      const doneCount = Object.keys(done).filter(key =>
        key.startsWith(`${date}:`)
      ).length;
      const isComplete = doneCount >= dayData.count;

      // Find the details element for this date
      const details = document.querySelector(`details[data-date="${date}"]`);
      if (!details) return;

      // Update the completed class
      if (isComplete) {
        details.classList.add('completed');
      } else {
        details.classList.remove('completed');
      }

      // Update the progress text
      const dayMeta = details.querySelector('.day-meta');
      const today = getTodayInIsrael();
      const isToday = date === today;
      const dateLabel = isToday ? '×”×™×•×' : formatHebrewDate(date);
      dayMeta.textContent = `${dateLabel} â€¢ ${doneCount}/${dayData.count}`;

      // Update button visibility
      const checkBtn = details.querySelector('.day-action-btn.check');
      const resetBtn = details.querySelector('.day-action-btn.reset');

      // Hide check button if all done
      if (isComplete) {
        checkBtn.style.display = 'none';
      } else {
        checkBtn.style.display = '';
      }

      // Hide reset button if nothing done
      if (doneCount === 0) {
        resetBtn.style.display = 'none';
      } else {
        resetBtn.style.display = '';
      }
    }

    // ============================================================================
    // Rendering
    // ============================================================================
    function renderDays() {
      const days = getDays();
      const done = getDone();
      const today = getTodayInIsrael();
      const start = getStart();

      const allDates = dateRange(start, today).reverse(); // Today first
      const mainContent = document.getElementById('mainContent');

      if (allDates.length === 0) {
        mainContent.innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">ğŸ“š</div>
            <div class="empty-state-title">×‘×¨×•×›×™× ×”×‘××™×!</div>
            <div class="empty-state-text">×˜×•×¢×Ÿ ××ª ×”×œ×™××•×“ ×”×™×•××™ ×©×œ×š...</div>
          </div>
        `;
        return;
      }

      mainContent.innerHTML = '';

      allDates.forEach(date => {
        const dayData = days[date];
        if (!dayData) return;

        const doneCount = Object.keys(done).filter(key =>
          key.startsWith(`${date}:`)
        ).length;
        const isComplete = doneCount >= dayData.count;

        // Don't skip any days - show all days (complete or incomplete)

        const details = document.createElement('details');
        details.className = `day-group ${isComplete ? 'completed' : ''}`;
        details.dataset.date = date;
        details.dataset.ref = dayData.ref;

        const isToday = date === today;
        const dateLabel = isToday ? '×”×™×•×' : formatHebrewDate(date);

        // Determine button visibility
        const showCheckBtn = !isComplete;
        const showResetBtn = doneCount > 0;

        details.innerHTML = `
          <summary>
            <div class="day-header">
              <span class="day-arrow">â—€</span>
              <div class="day-info">
                <div>${dayData.he}</div>
                <div class="day-meta">${dateLabel} â€¢ ${doneCount}/${dayData.count}</div>
              </div>
            </div>
            <div class="day-actions">
              <button class="day-action-btn check" data-action="complete" data-date="${date}" title="×¡××Ÿ ×”×›×œ ×›×”×•×©×œ×" aria-label="×¡××Ÿ ×”×›×œ ×›×”×•×©×œ×" style="display: ${showCheckBtn ? '' : 'none'}">âœ“</button>
              <button class="day-action-btn reset" data-action="reset" data-date="${date}" title="××¤×¡ ×™×•×" aria-label="××¤×¡ ×™×•×" style="display: ${showResetBtn ? '' : 'none'}">â†º</button>
            </div>
          </summary>
          <div class="cards-container" data-date="${date}"></div>
        `;

        mainContent.appendChild(details);
      });

      // Attach listeners to details elements
      document.querySelectorAll('details').forEach(details => {
        details.addEventListener('toggle', handleDetailsToggle);
      });

      // Attach listeners to action buttons
      document.querySelectorAll('.day-action-btn').forEach(btn => {
        btn.addEventListener('click', handleDayAction);
      });
    }

    function handleDayAction(event) {
      event.stopPropagation(); // Prevent summary toggle
      const btn = event.currentTarget;
      const action = btn.dataset.action;
      const date = btn.dataset.date;
      const days = getDays();
      const dayData = days[date];

      if (!dayData) return;

      if (action === 'reset') {
        if (!confirm(`×”×× ×œ××¤×¡ ××ª ×›×œ ×”×”×ª×§×“××•×ª ×©×œ ${dayData.he}?`)) return;

        // Remove all done entries for this date
        const done = getDone();
        Object.keys(done).forEach(key => {
          if (key.startsWith(`${date}:`)) {
            delete done[key];
          }
        });
        saveDone(done);

        // Refresh the display
        renderDays();
        renderStats();
      } else if (action === 'complete') {
        if (!confirm(`×”×× ×œ×¡××Ÿ ××ª ×›×œ ${dayData.he} ×›×”×•×©×œ×?`)) return;

        // Mark all halakhot as done
        const done = getDone();
        for (let i = 0; i < dayData.count; i++) {
          done[`${date}:${i}`] = new Date().toISOString();
        }
        saveDone(done);

        // Refresh the display
        renderDays();
        renderStats();
      }
    }

    async function handleDetailsToggle(event) {
      const details = event.target;
      if (!details.open) return;

      const date = details.dataset.date;
      const ref = details.dataset.ref;
      const container = details.querySelector('.cards-container');

      if (container.children.length > 0) return; // Already loaded

      container.innerHTML = '<div class="loading">×˜×•×¢×Ÿ ×”×œ×›×•×ª...</div>';

      try {
        const { halakhot, chapterBoundaries } = await fetchText(ref);
        const done = getDone();

        container.innerHTML = '';

        // Add first chapter label if there are multiple chapters
        if (chapterBoundaries.length > 0) {
          const firstDivider = document.createElement('div');
          firstDivider.className = 'chapter-divider';
          firstDivider.innerHTML = `<span>×¤×¨×§ ×</span>`;
          container.appendChild(firstDivider);
        }

        let currentChapter = 1;
        halakhot.forEach((text, index) => {
          // Add chapter divider if this is a chapter boundary
          if (chapterBoundaries.includes(index)) {
            currentChapter++;
            const divider = document.createElement('div');
            divider.className = 'chapter-divider';
            divider.innerHTML = `<span>×¤×¨×§ ${toHebrewLetter(currentChapter)}</span>`;
            container.appendChild(divider);
          }

          const isDone = done[`${date}:${index}`];

          const card = document.createElement('div');
          card.className = 'halakha-card';
          if (isDone) {
            card.classList.add('completed');
          }
          card.dataset.date = date;
          card.dataset.index = index;

          const hebrewNum = toHebrewLetter(index + 1);
          card.innerHTML = `
            <div class="halakha-text"><b>${hebrewNum}.</b> ${text}</div>
          `;

          attachSwipeHandler(card);
          container.appendChild(card);
        });
      } catch (error) {
        console.error('Failed to load halakhot:', error);
        container.innerHTML = '<div class="loading">âŒ ×©×’×™××” ×‘×˜×¢×™× ×”</div>';
      }
    }

    // ============================================================================
    // Scroll Helper
    // ============================================================================
    function scrollToCard(card) {
      if (!card) return;

      setTimeout(() => {
        card.scrollIntoView({
          behavior: 'smooth',
          block: 'center',
          inline: 'nearest'
        });
      }, 500);
    }

    // ============================================================================
    // Swipe Gesture & Double Click/Tap
    // ============================================================================
    function attachSwipeHandler(card) {
      let startX = 0;
      let startY = 0;
      let currentX = 0;
      let currentY = 0;
      let isSwiping = false;
      let isMouseDown = false;
      let lastTapTime = 0;

      // Mark card as done with all the checks and scrolling
      function markCardDone() {
        const date = card.dataset.date;
        const index = parseInt(card.dataset.index);
        const done = getDone();

        // Check if there are incomplete cards above this one
        const container = card.parentElement;
        const cards = Array.from(container.querySelectorAll('.halakha-card'));
        const currentIndex = cards.indexOf(card);

        const incompleteAbove = [];
        for (let i = 0; i < currentIndex; i++) {
          const aboveCard = cards[i];
          const aboveIndex = parseInt(aboveCard.dataset.index);
          if (!done[`${date}:${aboveIndex}`]) {
            incompleteAbove.push(aboveIndex);
          }
        }

        if (incompleteAbove.length > 0 && getAutoMark()) {
          // Auto-mark all incomplete cards above as done
          incompleteAbove.forEach(idx => {
            markDone(date, idx);
            const cardToMark = cards.find(c => parseInt(c.dataset.index) === idx);
            if (cardToMark) {
              cardToMark.classList.add('completed');
            }
          });
        }

        card.classList.add('completed');
        markDone(date, index);
        renderStats();
        updateDayHeader(date);

        // Scroll to next card
        let nextCard = card.nextElementSibling;
        while (nextCard && !nextCard.classList.contains('halakha-card')) {
          nextCard = nextCard.nextElementSibling;
        }
        scrollToCard(nextCard);
      }

      // Unmark card as done
      function unmarkCardDone() {
        const date = card.dataset.date;
        const index = parseInt(card.dataset.index);

        card.classList.remove('completed');
        const done = getDone();
        delete done[`${date}:${index}`];
        saveDone(done);
        renderStats();
        updateDayHeader(date);

        // Scroll to current card
        scrollToCard(card);
      }

      // Double-click/tap handler
      function handleToggle() {
        const date = card.dataset.date;
        const index = parseInt(card.dataset.index);
        const done = getDone();
        const isCompleted = done[`${date}:${index}`];

        if (isCompleted) {
          unmarkCardDone();
        } else {
          markCardDone();
        }
      }

      // Double-click for desktop
      card.addEventListener('dblclick', (e) => {
        e.preventDefault();
        handleToggle();
      });

      // Touch events (mobile)
      card.addEventListener('touchstart', (e) => {
        // Double-tap detection
        const now = Date.now();
        const timeSinceLastTap = now - lastTapTime;
        if (timeSinceLastTap < 300 && timeSinceLastTap > 0) {
          // Double tap detected
          e.preventDefault();
          handleToggle();
          lastTapTime = 0;
          return;
        }
        lastTapTime = now;

        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        currentX = startX;
        currentY = startY;
        isSwiping = false;
        card.classList.add('swiping');
      }, { passive: false });

      card.addEventListener('touchmove', (e) => {
        currentX = e.touches[0].clientX;
        currentY = e.touches[0].clientY;
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;

        if (!isSwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
          isSwiping = true;
        }

        if (isSwiping) {
          e.preventDefault();
          // Allow swiping in both directions
          card.style.transform = `translateX(${deltaX}px)`;
          card.style.opacity = 1 - (Math.abs(deltaX) / 300);
        }
      }, { passive: false });

      card.addEventListener('touchend', handleEnd, { passive: true });

      // Mouse events (desktop)
      card.addEventListener('mousedown', (e) => {
        isMouseDown = true;
        startX = e.clientX;
        startY = e.clientY;
        currentX = startX;
        currentY = startY;
        isSwiping = false;
        card.classList.add('swiping');
        e.preventDefault();
      });

      card.addEventListener('mousemove', (e) => {
        if (!isMouseDown) return;

        currentX = e.clientX;
        currentY = e.clientY;
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;

        if (!isSwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
          isSwiping = true;
        }

        if (isSwiping) {
          // Allow swiping in both directions
          card.style.transform = `translateX(${deltaX}px)`;
          card.style.opacity = 1 - (Math.abs(deltaX) / 300);
        }
      });

      card.addEventListener('mouseup', handleEnd);
      card.addEventListener('mouseleave', handleEnd);

      function handleEnd() {
        if (!isSwiping && !isMouseDown) {
          card.classList.remove('swiping');
          currentX = 0;
          currentY = 0;
          return;
        }

        card.classList.remove('swiping');
        isMouseDown = false;

        const deltaX = currentX - startX;
        const date = card.dataset.date;
        const index = parseInt(card.dataset.index);
        const done = getDone();
        const isCompleted = done[`${date}:${index}`];

        // Swipe right: mark as done
        if (isSwiping && deltaX > 100 && !isCompleted) {
          markCardDone();
        }
        // Swipe left: unmark as done
        else if (isSwiping && deltaX < -100 && isCompleted) {
          unmarkCardDone();
        }

        // Reset position
        card.style.transform = '';
        card.style.opacity = '';

        isSwiping = false;
        currentX = 0;
        currentY = 0;
      }
    }

    // ============================================================================
    // Settings
    // ============================================================================
    function openSettings() {
      document.getElementById('settingsPanel').classList.add('open');
      document.getElementById('overlay').classList.add('visible');
      updateLocationDisplay();
    }

    function closeSettings() {
      document.getElementById('settingsPanel').classList.remove('open');
      document.getElementById('overlay').classList.remove('visible');
    }

    document.getElementById('settingsBtn').addEventListener('click', openSettings);
    document.getElementById('closeBtn').addEventListener('click', closeSettings);
    document.getElementById('overlay').addEventListener('click', closeSettings);

    // Chapter count toggle
    document.querySelectorAll('.toggle-btn:not(.auto-mark)').forEach(btn => {
      btn.addEventListener('click', () => {
        const value = parseInt(btn.dataset.value);
        if (value !== getChapterCount()) {
          if (confirm(`×”×× ×œ×©× ×•×ª ×œ-${value === 1 ? '×¤×¨×§ ××—×“' : '3 ×¤×¨×§×™×'} ×œ×™×•×? ×–×” ×™××¤×¡ ××ª ×”×”×ª×§×“××•×ª ×©×œ×š.`)) {
            setChapterCount(value);
            localStorage.removeItem('rambam_days'); // Clear cached days
            location.reload();
          }
        }
      });
    });

    // Set initial active toggle button
    const currentChapterCount = getChapterCount();
    document.querySelectorAll('.toggle-btn:not(.auto-mark)').forEach(btn => {
      const value = parseInt(btn.dataset.value);
      if (value === currentChapterCount) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });

    // Auto-mark toggle
    const currentAutoMark = getAutoMark();
    document.querySelectorAll('.toggle-btn.auto-mark').forEach(btn => {
      const value = btn.dataset.value === 'true';
      if (value === currentAutoMark) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }

      btn.addEventListener('click', () => {
        const newValue = btn.dataset.value === 'true';
        setAutoMark(newValue);
        document.querySelectorAll('.toggle-btn.auto-mark').forEach(b => {
          b.classList.toggle('active', b.dataset.value === btn.dataset.value);
        });
      });
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      if (confirm('×”×× ××ª×” ×‘×˜×•×—? ×›×œ ×”×”×ª×§×“××•×ª ×ª×™××—×§.')) {
        localStorage.clear();
        location.reload();
      }
    });

    // Set start date input value
    const startDateInput = document.getElementById('startDateInput');
    const setCycleBtn = document.getElementById('setCycleBtn');

    function updateDateButtons() {
      const currentStart = getStart();
      const isCycleDate = currentStart === CYCLE_START;

      if (isCycleDate) {
        setCycleBtn.classList.remove('btn-secondary');
        setCycleBtn.classList.add('btn-primary');
        startDateInput.classList.add('date-input-inactive');
      } else {
        setCycleBtn.classList.remove('btn-primary');
        setCycleBtn.classList.add('btn-secondary');
        startDateInput.classList.remove('date-input-inactive');
      }
    }

    startDateInput.value = getStart();
    updateDateButtons();

    startDateInput.addEventListener('change', (e) => {
      const newStart = e.target.value;
      if (confirm(`×”×× ×œ×©× ×•×ª ××ª ×ª××¨×™×š ×”×”×ª×—×œ×” ×œ-${newStart}? ×–×” ×¢×œ×•×œ ×œ××¤×¡ ××ª ×”×”×ª×§×“××•×ª.`)) {
        setStart(newStart);
        location.reload();
      } else {
        e.target.value = getStart();
      }
    });

    setCycleBtn.addEventListener('click', () => {
      if (confirm('×”×× ×œ×§×‘×•×¢ ××ª ×ª××¨×™×š ×”×”×ª×—×œ×” ×œ×˜×´×• ×©×‘×˜ ×”×³×ª×©×¤×´×• (3 ×‘×¤×‘×¨×•××¨ 2026)?')) {
        setStart(CYCLE_START);
        location.reload();
      }
    });

    // Update location button
    document.getElementById('updateLocationBtn').addEventListener('click', async () => {
      const btn = document.getElementById('updateLocationBtn');
      const originalText = btn.textContent;
      btn.textContent = '××¢×“×›×Ÿ...';
      btn.disabled = true;

      try {
        const coords = await getUserCoords();
        const now = new Date();
        const israelTimeStr = now.toLocaleString('en-US', { timeZone: 'Asia/Jerusalem' });
        const israelTime = new Date(israelTimeStr);
        const year = israelTime.getFullYear();
        const month = String(israelTime.getMonth() + 1).padStart(2, '0');
        const day = String(israelTime.getDate()).padStart(2, '0');
        const rawDateStr = `${year}-${month}-${day}`;
        await fetchSunset(rawDateStr, coords);

        btn.textContent = 'âœ“ ×¢×•×“×›×Ÿ';
        setTimeout(() => {
          btn.textContent = originalText;
        }, 2000);
      } catch (error) {
        console.error('Failed to update location:', error);
        btn.textContent = 'âŒ ×©×’×™××”';
        setTimeout(() => {
          btn.textContent = originalText;
        }, 2000);
      } finally {
        btn.disabled = false;
      }
    });

    // ============================================================================
    // Calendar Date Picker
    // ============================================================================
    let viewingDate = null; // null means viewing normal mode (all days)

    const calendarBtn = document.getElementById('calendarBtn');
    const headerDatePicker = document.getElementById('headerDatePicker');
    const mainHeader = document.getElementById('mainHeader');

    calendarBtn.addEventListener('click', () => {
      if (viewingDate) {
        // Already viewing a specific date, return to normal mode
        viewingDate = null;
        renderDays();
        mainHeader.classList.remove('viewing-other-date');
      } else {
        // Open date picker
        headerDatePicker.showPicker();
      }
    });

    headerDatePicker.addEventListener('change', async (e) => {
      const selectedDate = e.target.value;
      viewingDate = selectedDate;

      const today = getTodayInIsrael();
      if (selectedDate !== today) {
        mainHeader.classList.add('viewing-other-date');
      } else {
        mainHeader.classList.remove('viewing-other-date');
      }

      await renderSingleDay(selectedDate);
    });

    async function renderSingleDay(date) {
      const days = getDays();
      const done = getDone();
      const today = getTodayInIsrael();
      const mainContent = document.getElementById('mainContent');

      // Check if we have this date cached
      let dayData = days[date];

      // If not cached, fetch it from Sefaria
      if (!dayData) {
        mainContent.innerHTML = '<div class="loading">×˜×•×¢×Ÿ...</div>';

        try {
          const { he, ref } = await fetchCalendar(date);
          const { halakhot } = await fetchText(ref);
          const heDate = await fetchHebrewDate(date);
          dayData = { he, ref, count: halakhot.length, heDate };

          // Cache it
          days[date] = dayData;
          saveDays(days);
        } catch (error) {
          console.error('Failed to fetch date:', error);
          mainContent.innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">âŒ</div>
              <div class="empty-state-title">×©×’×™××”</div>
              <div class="empty-state-text">×œ× × ×™×ª×Ÿ ×œ×˜×¢×•×Ÿ ××ª ×”× ×ª×•× ×™× ×œ×ª××¨×™×š ×–×”</div>
            </div>
          `;
          return;
        }
      }

      const doneCount = Object.keys(done).filter(key =>
        key.startsWith(`${date}:`)
      ).length;
      const isComplete = doneCount >= dayData.count;

      mainContent.innerHTML = '';

      const details = document.createElement('details');
      details.className = `day-group ${isComplete ? 'completed' : ''}`;
      details.dataset.date = date;
      details.dataset.ref = dayData.ref;
      details.open = true; // Auto-open when viewing single day

      const isToday = date === today;
      const dateLabel = isToday ? '×”×™×•×' : formatHebrewDate(date);

      const showCheckBtn = !isComplete;
      const showResetBtn = doneCount > 0;

      details.innerHTML = `
        <summary>
          <div class="day-header">
            <span class="day-arrow">â—€</span>
            <div class="day-info">
              <div>${dayData.he}</div>
              <div class="day-meta">${dateLabel} â€¢ ${doneCount}/${dayData.count}</div>
            </div>
          </div>
          <div class="day-actions">
            <button class="day-action-btn check" data-action="complete" data-date="${date}" title="×¡××Ÿ ×”×›×œ ×›×”×•×©×œ×" aria-label="×¡××Ÿ ×”×›×œ ×›×”×•×©×œ×" style="display: ${showCheckBtn ? '' : 'none'}">âœ“</button>
            <button class="day-action-btn reset" data-action="reset" data-date="${date}" title="××¤×¡ ×™×•×" aria-label="××¤×¡ ×™×•×" style="display: ${showResetBtn ? '' : 'none'}">â†º</button>
          </div>
        </summary>
        <div class="cards-container" data-date="${date}"></div>
      `;

      mainContent.appendChild(details);

      // Attach listeners
      details.addEventListener('toggle', handleDetailsToggle);
      details.querySelectorAll('.day-action-btn').forEach(btn => {
        btn.addEventListener('click', handleDayAction);
      });
    }

    // ============================================================================
    // PWA Install Prompt
    // ============================================================================
    let deferredPrompt;

    function showInstallButton() {
      const installHeaderBtn = document.getElementById('installHeaderBtn');
      if (installHeaderBtn) {
        installHeaderBtn.style.display = '';
      }
    }

    function hideInstallButton() {
      const installHeaderBtn = document.getElementById('installHeaderBtn');
      if (installHeaderBtn) {
        installHeaderBtn.style.display = 'none';
      }
    }

    async function triggerInstall() {
      if (!deferredPrompt) return;

      // Show the install prompt
      deferredPrompt.prompt();

      // Wait for the user to respond to the prompt
      const { outcome } = await deferredPrompt.userChoice;
      console.log(`User response to the install prompt: ${outcome}`);

      if (outcome === 'accepted') {
        hideInstallButton();
      }

      // Clear the deferredPrompt
      deferredPrompt = null;
    }

    window.addEventListener('beforeinstallprompt', (e) => {
      // Prevent the mini-infobar from appearing on mobile
      e.preventDefault();
      // Save the event so it can be triggered later
      deferredPrompt = e;

      // Show install button in header
      showInstallButton();

      // Show install prompt after user has interacted with the app
      // Don't show on first visit
      if (!isFirstVisit()) {
        const installPromptShown = localStorage.getItem('install_prompt_shown');
        if (!installPromptShown) {
          setTimeout(() => {
            document.getElementById('installPrompt').classList.add('show');
          }, 3000); // Show after 3 seconds
        }
      }
    });

    // Check if already installed
    window.addEventListener('appinstalled', () => {
      hideInstallButton();
      deferredPrompt = null;
    });

    // Header install button
    document.getElementById('installHeaderBtn').addEventListener('click', triggerInstall);

    // Prompt install button
    document.getElementById('installBtn').addEventListener('click', async () => {
      await triggerInstall();
      // Hide the prompt
      document.getElementById('installPrompt').classList.remove('show');
      localStorage.setItem('install_prompt_shown', 'true');
    });

    document.getElementById('dismissInstallBtn').addEventListener('click', () => {
      document.getElementById('installPrompt').classList.remove('show');
      localStorage.setItem('install_prompt_shown', 'true');
    });

    // ============================================================================
    // Service Worker Registration
    // ============================================================================
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => {
            console.log('Service Worker registered:', reg.scope);

            // Check for updates on load
            reg.update();

            // Listen for new service worker waiting to activate
            reg.addEventListener('updatefound', () => {
              const newWorker = reg.installing;
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New version available
                  if (confirm('×’×¨×¡×” ×—×“×©×” ×©×œ ×”××¤×œ×™×§×¦×™×” ×–××™× ×”! ×”×× ×œ×¨×¢× ×Ÿ ××ª ×”×“×£?')) {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                    window.location.reload();
                  }
                }
              });
            });
          })
          .catch(err => console.error('Service Worker registration failed:', err));

        // Reload page when new service worker takes control
        let refreshing = false;
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          if (!refreshing) {
            refreshing = true;
            window.location.reload();
          }
        });
      });
    }

    // ============================================================================
    // Changelog
    // ============================================================================
    function loadChangelog() {
      try {
        const container = document.getElementById('changelogContainer');
        if (!container) return;

        container.innerHTML = '';

        // Get version numbers and sort in descending order
        const versions = Object.keys(CHANGELOG).sort((a, b) => parseInt(b) - parseInt(a));

        versions.forEach(version => {
          const changes = CHANGELOG[version];
          if (!changes || changes.length === 0) return; // Skip empty versions (like 2.1)

          const details = document.createElement('details');
          details.className = 'changelog-version';
          if (version === versions[0]) {
            details.open = true; // Auto-open latest version
          }

          const summary = document.createElement('summary');
          summary.innerHTML = `<span class="changelog-arrow">â—€</span> ×’×¨×¡×” ${version}`;

          const itemsDiv = document.createElement('div');
          itemsDiv.className = 'changelog-items';

          changes.forEach(change => {
            const item = document.createElement('div');
            item.className = 'changelog-item';
            item.textContent = change;
            itemsDiv.appendChild(item);
          });

          details.appendChild(summary);
          details.appendChild(itemsDiv);
          container.appendChild(details);
        });
      } catch (error) {
        console.error('Failed to load changelog:', error);
      }
    }

    // ============================================================================
    // App Initialization
    // ============================================================================
    async function init() {
      try {
        // Check if this is the first visit BEFORE any other operations
        const firstVisit = isFirstVisit();

        // If first visit, set the default start date
        if (firstVisit) {
          localStorage.setItem('rambam_start', CYCLE_START);
        }

        // Load days first for fast initial render
        await loadMissingDays();
        renderDays();
        renderStats();

        // Load changelog
        loadChangelog();

        // Fetch coords and sunset in background (non-blocking)
        getUserCoords().then(coords => {
          const now = new Date();
          const israelTimeStr = now.toLocaleString('en-US', { timeZone: 'Asia/Jerusalem' });
          const israelTime = new Date(israelTimeStr);
          const year = israelTime.getFullYear();
          const month = String(israelTime.getMonth() + 1).padStart(2, '0');
          const day = String(israelTime.getDate()).padStart(2, '0');
          const rawDateStr = `${year}-${month}-${day}`;
          fetchSunset(rawDateStr, coords);
        });

        // Open settings on first visit
        if (firstVisit) {
          openSettings();
        } else {
          // Auto-open today's section if not completed (only if not first visit)
          const today = getTodayInIsrael();
          const days = getDays();
          const done = getDone();
          const todayData = days[today];

          if (todayData) {
            const todayDone = Object.keys(done).filter(key =>
              key.startsWith(`${today}:`)
            ).length;

            if (todayDone < todayData.count) {
              // Find and open today's details element
              const todayDetails = document.querySelector(`details[data-date="${today}"]`);
              if (todayDetails) {
                todayDetails.open = true;

                // Wait for cards to load, then scroll to first incomplete
                todayDetails.addEventListener('toggle', function scrollToIncomplete() {
                  if (todayDetails.open) {
                    setTimeout(() => {
                      const firstIncomplete = todayDetails.querySelector('.halakha-card:not(.completed)');
                      if (firstIncomplete) {
                        scrollToCard(firstIncomplete);
                      }
                    }, 800); // Give more time for cards to render
                  }
                }, { once: true });
              }
            }
          }
        }
      } catch (error) {
        console.error('Initialization failed:', error);
        document.getElementById('mainContent').innerHTML = `
          <div class="empty-state">
            <div class="empty-state-icon">âŒ</div>
            <div class="empty-state-title">×©×’×™××”</div>
            <div class="empty-state-text">×œ× × ×™×ª×Ÿ ×œ×˜×¢×•×Ÿ ××ª ×”× ×ª×•× ×™×. × ×¡×” ×©×•×‘ ×××•×—×¨ ×™×•×ª×¨.</div>
          </div>
        `;
      }
    }

    init();
  </script>
</body>
</html>
